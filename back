// ==== File: config/config.js ====
require('dotenv').config();

module.exports = {
  port: process.env.PORT || 5000,
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key-for-development',
  jwtExpiresIn: process.env.JWT_EXPIRES_IN || '7d',
  environment: process.env.NODE_ENV || 'development',
  apiUrl: process.env.API_URL || 'https://api.offer-hunt.com/v1',
  
  // Параметры подключения к базе данных
  dbUser: process.env.DB_USER || 'postgres',
  dbHost: process.env.DB_HOST || 'localhost',
  dbName: process.env.DB_NAME || 'offer_hunt',
  dbPassword: process.env.DB_PASSWORD || 'postgres',
  dbPort: process.env.DB_PORT || 5432,
  dbSsl: process.env.DB_SSL === 'true',
};

// ==== File: config/db.js ====
const { Pool } = require('pg');
const config = require('./config');

const pool = new Pool({
  user: config.dbUser,
  host: config.dbHost,
  database: config.dbName,
  password: config.dbPassword,
  port: config.dbPort,
  ssl: config.dbSsl ? { rejectUnauthorized: false } : false
});

// Проверка соединения с базой данных
pool.connect()
  .then(() => console.log('Connected to PostgreSQL'))
  .catch(err => console.error('Connection error', err.stack));

// Вспомогательная функция для выполнения запросов
const query = (text, params) => pool.query(text, params);

module.exports = {
  query,
  pool
};

// ==== File: controllers/authController.js ====
const User = require('../models/User');
const { generateToken } = require('../utils/jwt');

/**
 * Register a new user
 * @route POST /auth/register
 */
const register = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Проверяем, существует ли уже пользователь с таким email
    const existingUser = await User.findByEmail(email);
    if (existingUser) {
      return res.status(409).json({
        code: 'EMAIL_EXISTS',
        message: 'Email уже зарегистрирован'
      });
    }

    // Создаем нового пользователя
    const newUser = await User.create({
      email,
      password,
      fullName: fullName || email.split('@')[0] // Временное имя по умолчанию
    });

    res.status(201).json(newUser);
  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при регистрации'
    });
  }
};

/**
 * Login user
 * @route POST /auth/login
 */
const login = async (req, res) => {
  try {
    const { email, password, fullName } = req.body;

    // Находим пользователя по email (получаем полные данные включая пароль)
    const user = await User.findByEmail(email);
    if (!user) {
      return res.status(401).json({
        code: 'INVALID_CREDENTIALS',
        message: 'Неверный email или пароль'
      });
    }

    // Проверяем пароль
    const isPasswordValid = await User.comparePassword(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({
        code: 'INVALID_CREDENTIALS',
        message: 'Неверный email или пароль'
      });
    }

    // Генерируем токен
    const token = generateToken({
      id: user.id, 
      email: user.email, 
      role: user.role
    });

    // Форматируем данные пользователя для ответа (без пароля)
    const userForResponse = User.formatUserData(user);

    res.status(200).json({
      accessToken: token
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при входе'
    });
  }
};

module.exports = {
  register,
  login
};

// ==== File: controllers/courseController.js ====
const Course = require('../models/Course');

/**
 * Get all courses with filtering
 * @route GET /courses
 */
const getCourses = async (req, res) => {
  try {
    const { search, difficulty, sort, tags } = req.query;
    
    // Преобразуем строку тегов в массив, если они переданы
    const tagsArray = tags ? 
      (Array.isArray(tags) ? tags : tags.split(',')) : 
      [];
    
    const filters = {
      search,
      difficulty,
      sort,
      tags: tagsArray
    };
    
    const courses = await Course.findAll(filters);
    
    res.status(200).json(courses);
  } catch (error) {
    console.error('Get courses error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при получении курсов'
    });
  }
};

/**
 * Get single course by ID
 * @route GET /courses/:courseId
 */
const getCourseById = async (req, res) => {
  try {
    const { courseId } = req.params;
    const { version } = req.query;
    
    const course = await Course.findById(courseId, version ? parseInt(version) : null);
    
    if (!course) {
      return res.status(404).json({
        code: 'COURSE_NOT_FOUND',
        message: 'Курс не найден'
      });
    }
    
    res.status(200).json(course);
  } catch (error) {
    console.error('Get course error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при получении курса'
    });
  }
};

/**
 * Create a new course
 * @route POST /courses
 */
const createCourse = async (req, res) => {
  try {
    const courseData = req.body;
    const authorId = req.user.id;
    
    const newCourse = await Course.create(courseData, authorId);
    
    res.status(201).json(newCourse);
  } catch (error) {
    console.error('Create course error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при создании курса'
    });
  }
};

/**
 * Update a course
 * @route PUT /courses/:courseId
 */
const updateCourse = async (req, res) => {
  try {
    const { courseId } = req.params;
    const updateData = req.body;
    const authorId = req.user.id;
    
    try {
      const updatedCourse = await Course.update(courseId, updateData, authorId);
      res.status(200).json(updatedCourse);
    } catch (error) {
      if (error.message === 'Course not found or not authorized') {
        return res.status(403).json({
          code: 'FORBIDDEN',
          message: 'Вы не являетесь автором этого курса'
        });
      } else if (error.message === 'Cannot update published course') {
        return res.status(403).json({
          code: 'ALREADY_PUBLISHED',
          message: 'Нельзя редактировать опубликованный курс. Создайте новую версию.'
        });
      } else {
        throw error;
      }
    }
  } catch (error) {
    console.error('Update course error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при обновлении курса'
    });
  }
};

/**
 * Publish a course
 * @route POST /courses/:courseId/publish
 */
const publishCourse = async (req, res) => {
  try {
    const { courseId } = req.params;
    const authorId = req.user.id;
    
    try {
      const publishedCourse = await Course.publish(courseId, authorId);
      res.status(200).json(publishedCourse);
    } catch (error) {
      if (error.message === 'Course not found or not authorized') {
        return res.status(403).json({
          code: 'FORBIDDEN',
          message: 'Вы не являетесь автором этого курса'
        });
      } else {
        throw error;
      }
    }
  } catch (error) {
    console.error('Publish course error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при публикации курса'
    });
  }
};

module.exports = {
  getCourses,
  getCourseById,
  createCourse,
  updateCourse,
  publishCourse
};

// ==== File: controllers/enrollmentController.js ====
const Enrollment = require('../models/Enrollment');

/**
 * Enroll in a course
 * @route POST /courses/:courseId/enroll
 */
const enrollCourse = async (req, res) => {
  try {
    const { courseId } = req.params;
    const userId = req.user.id;
    
    try {
      const enrollment = await Enrollment.enrollCourse(userId, courseId);
      res.status(201).json(enrollment);
    } catch (error) {
      if (error.message === 'Already enrolled') {
        return res.status(409).json({
          code: 'ALREADY_ENROLLED',
          message: 'Вы уже записаны на этот курс'
        });
      } else if (error.message === 'Course not found or not published') {
        return res.status(404).json({
          code: 'COURSE_NOT_FOUND',
          message: 'Курс не найден или не опубликован'
        });
      } else {
        throw error;
      }
    }
  } catch (error) {
    console.error('Enroll course error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при записи на курс'
    });
  }
};

/**
 * Get enrollment progress
 * @route GET /courses/:courseId/progress
 */
const getProgress = async (req, res) => {
  try {
    const { courseId } = req.params;
    const userId = req.user.id;
    
    const progress = await Enrollment.getProgress(userId, courseId);
    
    if (!progress) {
      return res.status(404).json({
        code: 'ENROLLMENT_NOT_FOUND',
        message: 'Вы не записаны на этот курс'
      });
    }
    
    res.status(200).json(progress);
  } catch (error) {
    console.error('Get progress error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при получении прогресса'
    });
  }
};

/**
 * Rate a course
 * @route POST /courses/:courseId/rating
 */
const rateCourse = async (req, res) => {
  try {
    const { courseId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    if (!value || value < 1 || value > 5) {
      return res.status(400).json({
        code: 'INVALID_RATING',
        message: 'Оценка должна быть от 1 до 5'
      });
    }
    
    try {
      const rating = await Enrollment.rateCourse(userId, courseId, value);
      res.status(201).json(rating);
    } catch (error) {
      if (error.message === 'Not enrolled in the course') {
        return res.status(403).json({
          code: 'NOT_ENROLLED',
          message: 'Вы не записаны на этот курс'
        });
      } else if (error.message === 'Already rated') {
        return res.status(409).json({
          code: 'ALREADY_RATED',
          message: 'Вы уже оценили этот курс'
        });
      } else {
        throw error;
      }
    }
  } catch (error) {
    console.error('Rate course error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при оценке курса'
    });
  }
};

module.exports = {
  enrollCourse,
  getProgress,
  rateCourse
};

// ==== File: controllers/userController.js ====
const User = require('../models/User');
const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');

/**
 * Get current user profile
 * @route GET /users/me
 */
const getMe = async (req, res) => {
  console.log('getMe controller called, user ID:', req.user.id);
  try {
    // Находим пользователя по ID из токена
    const user = await User.findById(req.user.id);
    
    if (!user) {
      console.log('User not found in database');
      return res.status(404).json({
        code: 'USER_NOT_FOUND',
        message: 'Пользователь не найден'
      });
    }

    console.log('User found, returning data');
    res.status(200).json(user);
  } catch (error) {
    console.error('Get profile error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при получении профиля'
    });
  }
};

/**
 * Update user profile
 * @route PATCH /users/me
 */
const updateMe = async (req, res) => {
  try {
    // Обновляем данные пользователя
    const { fullName, avatarUrl } = req.body;
    
    const updatedUser = await User.update(req.user.id, {
      fullName,
      avatarUrl
    });

    res.status(200).json(updatedUser);
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при обновлении профиля'
    });
  }
};

/**
 * Upload user avatar
 * @route POST /users/me/avatar
 */
const uploadAvatar = async (req, res) => {
  try {
    if (!req.files || !req.files.avatar) {
      return res.status(400).json({
        code: 'NO_FILE',
        message: 'Файл не найден'
      });
    }

    const avatar = req.files.avatar;
    
    // Проверяем тип файла
    if (!avatar.mimetype.startsWith('image/')) {
      return res.status(400).json({
        code: 'INVALID_FILE_TYPE',
        message: 'Файл должен быть изображением'
      });
    }
    
    // Проверяем размер файла (ограничение 5MB)
    if (avatar.size > 5 * 1024 * 1024) {
      return res.status(400).json({
        code: 'FILE_TOO_LARGE',
        message: 'Размер файла не должен превышать 5MB'
      });
    }
    
    // Создаем уникальное имя файла
    const fileExt = path.extname(avatar.name);
    const fileName = `${uuidv4()}${fileExt}`;
    
    // Путь для сохранения файла
    const uploadDir = path.join(__dirname, '../public/uploads/avatars');
    
    // Убедимся, что папка существует
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    
    const filePath = path.join(uploadDir, fileName);
    
    // Сохраняем файл
    await avatar.mv(filePath);
    
    // URL для доступа к аватару
    const avatarUrl = `/uploads/avatars/${fileName}`;
    
    // Обновляем URL аватара в профиле пользователя
    await User.update(req.user.id, { avatarUrl });
    
    res.status(200).json({ avatarUrl });
  } catch (error) {
    console.error('Upload avatar error:', error);
    res.status(500).json({
      code: 'SERVER_ERROR',
      message: 'Ошибка при загрузке аватара'
    });
  }
};

module.exports = {
  getMe,
  updateMe,
  uploadAvatar
};

// ==== File: data/mockData.js ====
const { v4: uuidv4 } = require('uuid');

// Пользователи
const users = [
  {
    id: uuidv4(),
    email: 'ivan@example.com',
    password: '$2a$10$CwTycUXWue0Thq9StjUM0uQxTmLsYYo1xRySdvFXMccg5tpUALpre', // password: 'password'
    fullName: 'Иван Иванов',
    avatarUrl: null,
    role: 'author',
    stats: {
      activeCourses: 2,
      completedCourses: 5,
      avgScore: 78.4
    }
  },
  {
    id: uuidv4(),
    email: 'polina@example.com',
    password: '$2a$10$CwTycUXWue0Thq9StjUM0uQxTmLsYYo1xRySdvFXMccg5tpUALpre', // password: 'password'
    fullName: 'Полина Смирнова',
    avatarUrl: null,
    role: 'author',
    stats: {
      activeCourses: 1,
      completedCourses: 3,
      avgScore: 82.0
    }
  },
  {
    id: uuidv4(),
    email: 'user@example.com',
    password: '$2a$10$CwTycUXWue0Thq9StjUM0uQxTmLsYYo1xRySdvFXMccg5tpUALpre', // password: 'password'
    fullName: 'Тестовый Пользователь',
    avatarUrl: null,
    role: 'user',
    stats: {
      activeCourses: 3,
      completedCourses: 1,
      avgScore: 85.5
    }
  }
];

// Курсы
const courses = [
  {
    id: '1',
    authorId: users[0].id,
    authorName: users[0].fullName,
    coverUrl: '/images/courses/python.png',
    title: 'Подготовка к Python Middle собеседованию',
    description: 'Полноценный курс для подготовки к Python Middle собеседованиям.',
    difficulty: 'Middle',
    language: 'Python',
    tags: ['Python', 'Backend', 'Algorithms'],
    estimatedDuration: 20,
    version: 1,
    isPublished: true,
    stats: {
      enrollments: 156,
      avgCompletion: 73,
      avgScore: 4.9
    },
    lessons: [
      { id: '101', title: 'Основы Python', type: 'Theory', hasQuiz: true },
      { id: '102', title: 'Структуры данных', type: 'Theory', hasQuiz: true },
      { id: '103', title: 'Алгоритмы', type: 'Coding', hasQuiz: true }
    ]
  },
  {
    id: '2',
    authorId: users[1].id,
    authorName: users[1].fullName,
    coverUrl: '/images/courses/algos.png',
    title: 'Алгоритмы и структуры данных для собеседований',
    description: 'Разбор алгоритмов и структур данных, которые часто спрашивают на собеседованиях.',
    difficulty: 'Middle',
    language: 'JavaScript',
    tags: ['Algorithms', 'Data Structures', 'Leetcode'],
    estimatedDuration: 15,
    version: 1,
    isPublished: true,
    stats: {
      enrollments: 243,
      avgCompletion: 68,
      avgScore: 4.8
    },
    lessons: [
      { id: '201', title: 'Сложность алгоритмов', type: 'Theory', hasQuiz: true },
      { id: '202', title: 'Сортировки', type: 'Coding', hasQuiz: true },
      { id: '203', title: 'Деревья и графы', type: 'Theory', hasQuiz: true }
    ]
  },
  {
    id: '3',
    authorId: users[0].id,
    authorName: users[0].fullName,
    coverUrl: '/images/courses/anal.png',
    title: 'Интервью аналитика: SQL, Excel, кейсы',
    description: 'Всё, что нужно для успешного прохождения собеседования на позицию аналитика.',
    difficulty: 'Beginner',
    language: 'SQL',
    tags: ['SQL', 'Analytics', 'Excel'],
    estimatedDuration: 12,
    version: 1,
    isPublished: true,
    stats: {
      enrollments: 189,
      avgCompletion: 82,
      avgScore: 4.8
    },
    lessons: [
      { id: '301', title: 'Основы SQL', type: 'Theory', hasQuiz: true },
      { id: '302', title: 'Сложные запросы', type: 'Coding', hasQuiz: true },
      { id: '303', title: 'Аналитические кейсы', type: 'Theory', hasQuiz: false }
    ]
  },
  {
    id: '4',
    authorId: users[1].id,
    authorName: users[1].fullName,
    coverUrl: '/images/courses/softs.png',
    title: 'Расскажи о себе: soft skills на собеседовании',
    description: 'Как успешно презентовать себя и свои навыки на собеседовании.',
    difficulty: 'Beginner',
    language: 'Русский',
    tags: ['Soft skills', 'HR', 'Interview'],
    estimatedDuration: 8,
    version: 1,
    isPublished: true,
    stats: {
      enrollments: 315,
      avgCompletion: 91,
      avgScore: 5.0
    },
    lessons: [
      { id: '401', title: 'Самопрезентация', type: 'Theory', hasQuiz: true },
      { id: '402', title: 'Сложные вопросы', type: 'Theory', hasQuiz: true },
      { id: '403', title: 'Обратная связь', type: 'Theory', hasQuiz: false }
    ]
  },
  {
    id: '5',
    authorId: users[0].id,
    authorName: users[0].fullName,
    coverUrl: '/images/courses/sysdis.png',
    title: 'System Design для Senior',
    description: 'Подготовка к вопросам по системному дизайну для позиции Senior Developer.',
    difficulty: 'Senior',
    language: 'English',
    tags: ['System Design', 'Architecture', 'Senior'],
    estimatedDuration: 25,
    version: 1,
    isPublished: true,
    stats: {
      enrollments: 142,
      avgCompletion: 62,
      avgScore: 4.7
    },
    lessons: [
      { id: '501', title: 'Основы системного дизайна', type: 'Theory', hasQuiz: true },
      { id: '502', title: 'Масштабирование', type: 'Theory', hasQuiz: true },
      { id: '503', title: 'Практические кейсы', type: 'Coding', hasQuiz: true }
    ]
  },
  {
    id: '6',
    authorId: users[1].id,
    authorName: users[1].fullName,
    coverUrl: '/images/courses/js.png',
    title: 'JavaScript для Junior Frontend',
    description: 'Всё, что нужно знать Junior Frontend разработчику о JavaScript.',
    difficulty: 'Beginner',
    language: 'JavaScript',
    tags: ['JavaScript', 'Frontend', 'Web'],
    estimatedDuration: 18,
    version: 1,
    isPublished: true,
    stats: {
      enrollments: 278,
      avgCompletion: 76,
      avgScore: 5.0
    },
    lessons: [
      { id: '601', title: 'Основы JavaScript', type: 'Theory', hasQuiz: true },
      { id: '602', title: 'DOM манипуляции', type: 'Theory', hasQuiz: true },
      { id: '603', title: 'Асинхронный JavaScript', type: 'Coding', hasQuiz: true }
    ]
  }
];

// Уроки (полный контент)
const lessons = [
  {
    id: '101',
    courseId: '1',
    title: 'Основы Python',
    type: 'Theory',
    hasQuiz: true,
    content: `# Основы Python для Middle разработчика
    
Этот урок охватывает ключевые аспекты Python, которые часто спрашивают на собеседованиях.

## Типы данных

Python имеет следующие встроенные типы данных:
- Числа (int, float, complex)
- Строки (str)
- Списки (list)
- Кортежи (tuple)
- Словари (dict)
- Множества (set, frozenset)

## GIL (Global Interpreter Lock)

GIL - это механизм в интерпретаторе CPython, который позволяет только одному потоку исполнять Python байт-код в любой момент времени.`,
    videoUrl: 'https://example.com/videos/python-basics',
    quiz: [
      {
        id: uuidv4(),
        text: 'Что такое GIL в Python?',
        type: 'longText'
      },
      {
        id: uuidv4(),
        text: 'Выберите все встроенные типы данных в Python:',
        type: 'choice',
        options: [
          { id: '1', label: 'int' },
          { id: '2', label: 'array' },
          { id: '3', label: 'dict' },
          { id: '4', label: 'queue' },
          { id: '5', label: 'set' }
        ]
      }
    ]
  },
  // Остальные уроки можно добавить аналогично
];

// Записи на курсы
const enrollments = [
  {
    userId: users[2].id,
    courseId: '1',
    status: 'inProgress',
    progress: 65,
    startedAt: new Date('2023-05-01'),
    finishedAt: null
  },
  {
    userId: users[2].id,
    courseId: '3',
    status: 'completed',
    progress: 100,
    startedAt: new Date('2023-04-15'),
    finishedAt: new Date('2023-05-10')
  }
];

// Оценки курсов
const ratings = [
  {
    userId: users[2].id,
    courseId: '3',
    value: 5,
    createdAt: new Date('2023-05-11')
  }
];

module.exports = {
  users,
  courses,
  lessons,
  enrollments,
  ratings
};

// ==== File: middleware/auth.js ====
const { verifyToken } = require('../utils/jwt');

/**
 * Middleware to protect routes that require authentication
 */
const protect = (req, res, next) => {
  // Get token from Authorization header
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      code: 'UNAUTHORIZED',
      message: 'Требуется авторизация'
    });
  }

  // Extract token
  const token = authHeader.split(' ')[1];

  // Verify token
  const decoded = verifyToken(token);
  if (!decoded) {
    return res.status(401).json({
      code: 'INVALID_TOKEN',
      message: 'Недействительный токен'
    });
  }

  // Set user on request object
  req.user = decoded;
  next();
};

/**
 * Middleware to check if user is an author
 */
const authorOnly = (req, res, next) => {
  if (!req.user || req.user.role !== 'author') {
    return res.status(403).json({
      code: 'FORBIDDEN',
      message: 'Доступ разрешен только авторам'
    });
  }
  next();
};

module.exports = {
  protect,
  authorOnly
};

// ==== File: middleware/errorHandler.js ====
/**
 * Global error handling middleware
 */
const errorHandler = (err, req, res, next) => {
  console.error(err.stack);

  const statusCode = err.statusCode || 500;
  const errorCode = err.code || 'INTERNAL_SERVER_ERROR';
  const message = err.message || 'Что-то пошло не так';

  res.status(statusCode).json({
    code: errorCode,
    message
  });
};

module.exports = errorHandler;

// ==== File: models/Course.js ====
const db = require('../config/db');
const { v4: uuidv4 } = require('uuid');

/**
 * Получение всех курсов с фильтрацией
 * @param {Object} filters - Параметры фильтрации
 * @returns {Promise<Array>} - Массив курсов
 */
const findAll = async (filters = {}) => {
  const { search, difficulty, sort, tags = [] } = filters;
  
  let query = `
    SELECT 
      c.id, 
      c.author_id, 
      u.full_name AS author_name,
      c.title, 
      c.description, 
      c.difficulty, 
      c.language, 
      c.cover_url, 
      c.estimated_duration, 
      c.version, 
      c.is_published,
      COALESCE(cs.enrollments, 0) AS enrollments, 
      COALESCE(cs.avg_completion, 0) AS avg_completion, 
      COALESCE(cs.avg_score, 0) AS avg_score
    FROM 
      courses c
    JOIN 
      users u ON c.author_id = u.id
    LEFT JOIN 
      course_stats cs ON c.id = cs.course_id
  `;
  
  const whereConditions = [];
  const values = [];
  let valueCounter = 1;
  
  // Фильтрация по опубликованным курсам (по умолчанию)
  whereConditions.push(`c.is_published = true`);
  
  // Поиск по тексту
  if (search) {
    whereConditions.push(`(
      c.title ILIKE $${valueCounter} 
      OR u.full_name ILIKE $${valueCounter} 
      OR EXISTS (
        SELECT 1 FROM course_tags ct 
        WHERE ct.course_id = c.id AND ct.tag ILIKE $${valueCounter}
      )
    )`);
    values.push(`%${search}%`);
    valueCounter++;
  }
  
  // Фильтрация по сложности
  if (difficulty) {
    whereConditions.push(`c.difficulty = $${valueCounter}`);
    values.push(difficulty);
    valueCounter++;
  }
  
  // Фильтрация по тегам
  if (tags.length > 0) {
    const placeholders = tags.map((_, idx) => `$${valueCounter + idx}`).join(', ');
    whereConditions.push(`EXISTS (
      SELECT 1 FROM course_tags ct 
      WHERE ct.course_id = c.id AND ct.tag IN (${placeholders})
    )`);
    values.push(...tags);
    valueCounter += tags.length;
  }
  
  if (whereConditions.length > 0) {
    query += ` WHERE ${whereConditions.join(' AND ')}`;
  }
  
  // Сортировка
  if (sort) {
    switch (sort) {
      case 'popularity':
        query += ` ORDER BY enrollments DESC`;
        break;
      case 'difficulty':
        query += ` ORDER BY CASE 
          WHEN c.difficulty = 'Beginner' THEN 1 
          WHEN c.difficulty = 'Middle' THEN 2 
          WHEN c.difficulty = 'Senior' THEN 3 
          ELSE 4 
        END`;
        break;
      case 'duration':
        query += ` ORDER BY c.estimated_duration DESC`;
        break;
      default:
        query += ` ORDER BY c.created_at DESC`;
    }
  } else {
    query += ` ORDER BY c.created_at DESC`;
  }
  
  const result = await db.query(query, values);
  
  // Получаем теги для каждого курса
  const courses = await Promise.all(result.rows.map(async course => {
    const tags = await getCourseTags(course.id);
    const lessons = await getCourseLessons(course.id);
    
    return formatCourseData(course, tags, lessons);
  }));
  
  return courses;
};

/**
 * Получение курса по ID
 * @param {string} id - ID курса
 * @param {number} version - Версия курса (опционально)
 * @returns {Promise<Object|null>} - Найденный курс или null
 */
const findById = async (id, version = null) => {
  let query = `
    SELECT 
      c.id, 
      c.author_id, 
      u.full_name AS author_name,
      c.title, 
      c.description, 
      c.difficulty, 
      c.language, 
      c.cover_url, 
      c.estimated_duration, 
      c.version, 
      c.is_published,
      COALESCE(cs.enrollments, 0) AS enrollments, 
      COALESCE(cs.avg_completion, 0) AS avg_completion, 
      COALESCE(cs.avg_score, 0) AS avg_score
    FROM 
      courses c
    JOIN 
      users u ON c.author_id = u.id
    LEFT JOIN 
      course_stats cs ON c.id = cs.course_id
    WHERE c.id = $1
  `;
  
  const values = [id];
  
  if (version) {
    query += ` AND c.version = $2`;
    values.push(version);
  }
  
  const result = await db.query(query, values);
  
  if (result.rows.length === 0) {
    return null;
  }
  
  const course = result.rows[0];
  const tags = await getCourseTags(id);
  const lessons = await getCourseLessons(id);
  
  return formatCourseData(course, tags, lessons);
};

/**
 * Создание нового курса
 * @param {Object} courseData - Данные курса
 * @param {string} authorId - ID автора
 * @returns {Promise<Object>} - Созданный курс
 */
const create = async (courseData, authorId) => {
  const { title, description, difficulty, language, tags = [], lessons = [] } = courseData;
  
  // Транзакция для создания курса и связанных данных
  const client = await db.pool.connect();
  
  try {
    await client.query('BEGIN');
    
    // Создаем курс
    const courseResult = await client.query(
      `INSERT INTO courses 
        (author_id, title, description, difficulty, language, version, is_published) 
       VALUES 
        ($1, $2, $3, $4, $5, $6, $7) 
       RETURNING *`,
      [authorId, title, description, difficulty, language, 1, false]
    );
    
    const course = courseResult.rows[0];
    
    // Создаем начальную статистику курса
    await client.query(
      `INSERT INTO course_stats 
        (course_id, enrollments, avg_completion, avg_score) 
       VALUES 
        ($1, $2, $3, $4)`,
      [course.id, 0, 0, 0]
    );
    
    // Добавляем теги
    if (tags.length > 0) {
      const tagValues = tags.map(tag => `('${course.id}', '${tag}')`).join(', ');
      await client.query(
        `INSERT INTO course_tags (course_id, tag) VALUES ${tagValues}`
      );
    }
    
    // Добавляем уроки
    if (lessons.length > 0) {
      for (let i = 0; i < lessons.length; i++) {
        const lesson = lessons[i];
        
        // Создаем урок
        const lessonResult = await client.query(
          `INSERT INTO lessons 
            (course_id, title, type, sort_order) 
           VALUES 
            ($1, $2, $3, $4) 
           RETURNING *`,
          [course.id, lesson.title, lesson.type, i]
        );
        
        const createdLesson = lessonResult.rows[0];
        
        // Добавляем содержимое урока
        if (lesson.content) {
          await client.query(
            `INSERT INTO lesson_content 
              (lesson_id, content, video_url) 
             VALUES 
              ($1, $2, $3)`,
            [createdLesson.id, lesson.content, lesson.videoUrl || null]
          );
        }
        
        // Добавляем вопросы для квиза
        if (lesson.quiz && lesson.quiz.length > 0) {
          for (let j = 0; j < lesson.quiz.length; j++) {
            const question = lesson.quiz[j];
            
            // Создаем вопрос
            const questionResult = await client.query(
              `INSERT INTO questions 
                (lesson_id, text, type, sort_order) 
               VALUES 
                ($1, $2, $3, $4) 
               RETURNING *`,
              [createdLesson.id, question.text, question.type, j]
            );
            
            const createdQuestion = questionResult.rows[0];
            
            // Добавляем варианты ответов для вопросов с выбором
            if (question.type === 'choice' && question.options && question.options.length > 0) {
              for (let k = 0; k < question.options.length; k++) {
                const option = question.options[k];
                
                await client.query(
                  `INSERT INTO question_options 
                    (question_id, label, sort_order) 
                   VALUES 
                    ($1, $2, $3)`,
                  [createdQuestion.id, option.label, k]
                );
              }
            }
          }
        }
      }
    }
    
    // Обновляем estimated_duration на основе количества уроков
    const estimatedDuration = Math.ceil(lessons.length * 2); // Примерно 2 часа на урок
    
    await client.query(
      `UPDATE courses SET estimated_duration = $1 WHERE id = $2`,
      [estimatedDuration, course.id]
    );
    
    await client.query('COMMIT');
    
    // Получаем полную информацию о курсе
    return await findById(course.id);
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
};

/**
 * Обновление курса
 * @param {string} id - ID курса
 * @param {Object} updateData - Данные для обновления
 * @param {string} authorId - ID автора
 * @returns {Promise<Object>} - Обновленный курс
 */
const update = async (id, updateData, authorId) => {
  // Проверяем, существует ли курс и принадлежит ли он автору
  const existingCourse = await db.query(
    'SELECT * FROM courses WHERE id = $1 AND author_id = $2',
    [id, authorId]
  );
  
  if (existingCourse.rows.length === 0) {
    throw new Error('Course not found or not authorized');
  }
  
  const course = existingCourse.rows[0];
  
  // Проверяем, опубликован ли курс
  if (course.is_published) {
    throw new Error('Cannot update published course');
  }
  
  const { title, description, difficulty, language, tags, lessons } = updateData;
  
  // Транзакция для обновления курса и связанных данных
  const client = await db.pool.connect();
  
  try {
    await client.query('BEGIN');
    
    // Обновляем основные данные курса
    const updateFields = [];
    const values = [];
    let counter = 1;
    
    if (title !== undefined) {
      updateFields.push(`title = $${counter}`);
      values.push(title);
      counter++;
    }
    
    if (description !== undefined) {
      updateFields.push(`description = $${counter}`);
      values.push(description);
      counter++;
    }
    
    if (difficulty !== undefined) {
      updateFields.push(`difficulty = $${counter}`);
      values.push(difficulty);
      counter++;
    }
    
    if (language !== undefined) {
      updateFields.push(`language = $${counter}`);
      values.push(language);
      counter++;
    }
    
    if (updateFields.length > 0) {
      values.push(id);
      
      await client.query(
        `UPDATE courses SET ${updateFields.join(', ')} WHERE id = $${counter}`,
        values
      );
    }
    
    // Обновляем теги
    if (tags !== undefined) {
      // Удаляем существующие теги
      await client.query('DELETE FROM course_tags WHERE course_id = $1', [id]);
      
      // Добавляем новые теги
      if (tags.length > 0) {
        const tagValues = tags.map(tag => `('${id}', '${tag}')`).join(', ');
        await client.query(
          `INSERT INTO course_tags (course_id, tag) VALUES ${tagValues}`
        );
      }
    }
    
    // Обновляем уроки
    if (lessons !== undefined) {
      // Получаем существующие уроки
      const existingLessons = await client.query(
        'SELECT id FROM lessons WHERE course_id = $1',
        [id]
      );
      
      const existingLessonIds = existingLessons.rows.map(row => row.id);
      
      // Создаем или обновляем уроки
      for (let i = 0; i < lessons.length; i++) {
        const lesson = lessons[i];
        
        if (lesson.id && existingLessonIds.includes(lesson.id)) {
          // Обновляем существующий урок
          await client.query(
            'UPDATE lessons SET title = $1, type = $2, sort_order = $3 WHERE id = $4',
            [lesson.title, lesson.type, i, lesson.id]
          );
          
          // Удаляем из списка существующих уроков
          const index = existingLessonIds.indexOf(lesson.id);
          if (index > -1) {
            existingLessonIds.splice(index, 1);
          }
          
          // Обновляем содержимое урока
          if (lesson.content !== undefined) {
            const contentExists = await client.query(
              'SELECT 1 FROM lesson_content WHERE lesson_id = $1',
              [lesson.id]
            );
            
            if (contentExists.rows.length > 0) {
              await client.query(
                'UPDATE lesson_content SET content = $1, video_url = $2 WHERE lesson_id = $3',
                [lesson.content, lesson.videoUrl || null, lesson.id]
              );
            } else {
              await client.query(
                'INSERT INTO lesson_content (lesson_id, content, video_url) VALUES ($1, $2, $3)',
                [lesson.id, lesson.content, lesson.videoUrl || null]
              );
            }
          }
          
          // Обновляем вопросы (удаляем старые и добавляем новые)
          if (lesson.quiz !== undefined) {
            await client.query('DELETE FROM questions WHERE lesson_id = $1', [lesson.id]);
            
            if (lesson.quiz && lesson.quiz.length > 0) {
              for (let j = 0; j < lesson.quiz.length; j++) {
                const question = lesson.quiz[j];
                
                // Создаем вопрос
                const questionResult = await client.query(
                  `INSERT INTO questions 
                    (lesson_id, text, type, sort_order) 
                   VALUES 
                    ($1, $2, $3, $4) 
                   RETURNING *`,
                  [lesson.id, question.text, question.type, j]
                );
                
                const createdQuestion = questionResult.rows[0];
                
                // Добавляем варианты ответов для вопросов с выбором
                if (question.type === 'choice' && question.options && question.options.length > 0) {
                  for (let k = 0; k < question.options.length; k++) {
                    const option = question.options[k];
                    
                    await client.query(
                      `INSERT INTO question_options 
                        (question_id, label, sort_order) 
                       VALUES 
                        ($1, $2, $3)`,
                      [createdQuestion.id, option.label, k]
                    );
                  }
                }
              }
            }
          }
        } else {
          // Создаем новый урок
          const lessonResult = await client.query(
            `INSERT INTO lessons 
              (course_id, title, type, sort_order) 
             VALUES 
              ($1, $2, $3, $4) 
             RETURNING *`,
            [id, lesson.title, lesson.type, i]
          );
          
          const createdLesson = lessonResult.rows[0];
          
          // Добавляем содержимое урока
          if (lesson.content) {
            await client.query(
              `INSERT INTO lesson_content 
                (lesson_id, content, video_url) 
               VALUES 
                ($1, $2, $3)`,
              [createdLesson.id, lesson.content, lesson.videoUrl || null]
            );
          }
          
          // Добавляем вопросы для квиза
          if (lesson.quiz && lesson.quiz.length > 0) {
            for (let j = 0; j < lesson.quiz.length; j++) {
              const question = lesson.quiz[j];
              
              // Создаем вопрос
              const questionResult = await client.query(
                `INSERT INTO questions 
                  (lesson_id, text, type, sort_order) 
                 VALUES 
                  ($1, $2, $3, $4) 
                 RETURNING *`,
                [createdLesson.id, question.text, question.type, j]
              );
              
              const createdQuestion = questionResult.rows[0];
              
              // Добавляем варианты ответов для вопросов с выбором
              if (question.type === 'choice' && question.options && question.options.length > 0) {
                for (let k = 0; k < question.options.length; k++) {
                  const option = question.options[k];
                  
                  await client.query(
                    `INSERT INTO question_options 
                      (question_id, label, sort_order) 
                     VALUES 
                      ($1, $2, $3)`,
                    [createdQuestion.id, option.label, k]
                  );
                }
              }
            }
          }
        }
      }
      
      // Удаляем уроки, которых нет в обновленном списке
      for (const lessonId of existingLessonIds) {
        await client.query('DELETE FROM lessons WHERE id = $1', [lessonId]);
      }
      
      // Обновляем estimated_duration на основе количества уроков
      const estimatedDuration = Math.ceil(lessons.length * 2); // Примерно 2 часа на урок
      
      await client.query(
        `UPDATE courses SET estimated_duration = $1 WHERE id = $2`,
        [estimatedDuration, id]
      );
    }
    
    await client.query('COMMIT');
    
    // Получаем полную информацию о курсе
    return await findById(id);
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
};

/**
 * Публикация курса
 * @param {string} id - ID курса
 * @param {string} authorId - ID автора
 * @returns {Promise<Object>} - Опубликованный курс
 */
const publish = async (id, authorId) => {
  // Проверяем, существует ли курс и принадлежит ли он автору
  const existingCourse = await db.query(
    'SELECT * FROM courses WHERE id = $1 AND author_id = $2',
    [id, authorId]
  );
  
  if (existingCourse.rows.length === 0) {
    throw new Error('Course not found or not authorized');
  }
  
  const course = existingCourse.rows[0];
  
  // Увеличиваем версию и публикуем курс
  await db.query(
    'UPDATE courses SET is_published = true, version = version + 1 WHERE id = $1',
    [id]
  );
  
  // Получаем обновленный курс
  return await findById(id);
};

/**
 * Получение тегов курса
 * @param {string} courseId - ID курса
 * @returns {Promise<Array>} - Массив тегов
 */
const getCourseTags = async (courseId) => {
  const result = await db.query(
    'SELECT tag FROM course_tags WHERE course_id = $1',
    [courseId]
  );
  
  return result.rows.map(row => row.tag);
};

/**
 * Получение уроков курса
 * @param {string} courseId - ID курса
 * @returns {Promise<Array>} - Массив уроков
 */
const getCourseLessons = async (courseId) => {
  const result = await db.query(
    `SELECT 
      l.id, 
      l.title, 
      l.type,
      CASE WHEN EXISTS (
        SELECT 1 FROM questions q WHERE q.lesson_id = l.id
      ) THEN true ELSE false END AS has_quiz
     FROM 
      lessons l
     WHERE 
      l.course_id = $1
     ORDER BY 
      l.sort_order`,
    [courseId]
  );
  
  return result.rows.map(row => ({
    id: row.id,
    title: row.title,
    type: row.type,
    hasQuiz: row.has_quiz
  }));
};

/**
 * Форматирование данных курса для API
 * @param {Object} courseData - Данные курса из базы
 * @param {Array} tags - Теги курса
 * @param {Array} lessons - Уроки курса
 * @returns {Object} - Форматированные данные курса
 */
const formatCourseData = (courseData, tags, lessons) => {
  return {
    id: courseData.id,
    authorId: courseData.author_id,
    authorName: courseData.author_name,
    title: courseData.title,
    description: courseData.description,
    difficulty: courseData.difficulty,
    language: courseData.language,
    coverUrl: courseData.cover_url,
    tags: tags,
    estimatedDuration: courseData.estimated_duration,
    version: courseData.version,
    isPublished: courseData.is_published,
    stats: {
      enrollments: parseInt(courseData.enrollments) || 0,
      avgCompletion: parseFloat(courseData.avg_completion) || 0,
      avgScore: parseFloat(courseData.avg_score) || 0
    },
    lessons: lessons
  };
};

module.exports = {
  findAll,
  findById,
  create,
  update,
  publish
};

// ==== File: models/Enrollment.js ====


// ==== File: models/Lesson.js ====


// ==== File: models/Rating.js ====


// ==== File: models/User.js ====
const db = require('../config/db');
const bcrypt = require('bcryptjs');

/**
 * Поиск пользователя по email
 * @param {string} email - Email пользователя
 * @returns {Promise<Object|null>} - Найденный пользователь или null
 */
const findByEmail = async (email) => {
  const result = await db.query(
    'SELECT u.*, us.active_courses, us.completed_courses, us.avg_score FROM users u ' +
    'LEFT JOIN user_stats us ON u.id = us.user_id ' +
    'WHERE u.email = $1',
    [email]
  );
  
  if (result.rows.length === 0) {
    return null;
  }

  // ВАЖНО: Возвращаем полный объект включая password для внутреннего использования
  // Не форматируем данные здесь, чтобы сохранить password
  return result.rows[0];
};

/**
 * Поиск пользователя по ID
 * @param {string} id - ID пользователя
 * @returns {Promise<Object|null>} - Найденный пользователь или null
 */
const findById = async (id) => {
  const result = await db.query(
    'SELECT u.*, us.active_courses, us.completed_courses, us.avg_score FROM users u ' +
    'LEFT JOIN user_stats us ON u.id = us.user_id ' +
    'WHERE u.id = $1',
    [id]
  );
  
  if (result.rows.length === 0) {
    return null;
  }

  // Здесь форматируем данные, т.к. этот метод используется для API ответов
  return formatUserData(result.rows[0]);
};

/**
 * Создание нового пользователя
 * @param {Object} userData - Данные пользователя
 * @returns {Promise<Object>} - Созданный пользователь
 */
const create = async (userData) => {
  const { email, password, fullName = null } = userData;
  const hashedPassword = await bcrypt.hash(password, 10);
  
  // Транзакция для создания пользователя и его статистики
  const client = await db.pool.connect();
  
  try {
    await client.query('BEGIN');
    
    // Создаем пользователя
    const userResult = await client.query(
      'INSERT INTO users (email, password, full_name, role) VALUES ($1, $2, $3, $4) RETURNING *',
      [email, hashedPassword, fullName, 'user']
    );
    
    const user = userResult.rows[0];
    
    // Создаем запись статистики
    await client.query(
      'INSERT INTO user_stats (user_id, active_courses, completed_courses, avg_score) VALUES ($1, $2, $3, $4)',
      [user.id, 0, 0, 0]
    );
    
    await client.query('COMMIT');
    
    // Получаем полную информацию о пользователе
    const fullUser = await findById(user.id);
    return fullUser;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
};

/**
 * Обновление данных пользователя
 * @param {string} id - ID пользователя
 * @param {Object} updateData - Данные для обновления
 * @returns {Promise<Object>} - Обновленный пользователь
 */
const update = async (id, updateData) => {
  const { fullName, avatarUrl } = updateData;
  const updateFields = [];
  const values = [];
  let counter = 1;
  
  if (fullName !== undefined) {
    updateFields.push(`full_name = $${counter}`);
    values.push(fullName);
    counter++;
  }
  
  if (avatarUrl !== undefined) {
    updateFields.push(`avatar_url = $${counter}`);
    values.push(avatarUrl);
    counter++;
  }
  
  if (updateFields.length === 0) {
    return await findById(id);
  }
  
  values.push(id);
  
  const result = await db.query(
    `UPDATE users SET ${updateFields.join(', ')} WHERE id = $${counter} RETURNING *`,
    values
  );
  
  return await findById(id);
};

/**
 * Форматирование данных пользователя для API
 * @param {Object} userData - Данные пользователя из базы
 * @returns {Object} - Форматированные данные пользователя
 */
const formatUserData = (userData) => {
  const { password, ...userWithoutPassword } = userData;
  
  return {
    id: userData.id,
    email: userData.email,
    fullName: userData.full_name,
    avatarUrl: userData.avatar_url,
    role: userData.role,
    stats: {
      activeCourses: userData.active_courses || 0,
      completedCourses: userData.completed_courses || 0,
      avgScore: userData.avg_score || 0
    }
  };
};

/**
 * Проверка пароля
 * @param {string} password - Введенный пароль
 * @param {string} hashedPassword - Хэшированный пароль из базы
 * @returns {Promise<boolean>} - Результат проверки
 */
const comparePassword = async (password, hashedPassword) => {
  return await bcrypt.compare(password, hashedPassword);
};

/**
 * Обновление аватара пользователя
 * @param {string} id - ID пользователя
 * @param {string} avatarUrl - URL аватара
 * @returns {Promise<Object>} - Обновленный пользователь
 */
const updateAvatar = async (id, avatarUrl) => {
  await db.query(
    'UPDATE users SET avatar_url = $1 WHERE id = $2',
    [avatarUrl, id]
  );
  
  return await findById(id);
};

module.exports = {
  findByEmail,
  findById,
  create,
  update,
  comparePassword,
  updateAvatar,
  formatUserData // Экспортируем для использования в контроллере
};

// ==== File: routes/authRoutes.js ====
const express = require('express');
const router = express.Router();
const { register, login } = require('../controllers/authController');

/**
 * @route POST /auth/register
 * @desc Register a new user
 * @access Public
 */
router.post('/register', register);

/**
 * @route POST /auth/login
 * @desc Login user and return JWT token
 * @access Public
 */
router.post('/login', login);

module.exports = router;

// ==== File: routes/courseRoutes.js ====
const express = require('express');
const router = express.Router();
const { 
  getCourses, 
  getCourseById, 
  createCourse, 
  updateCourse, 
  publishCourse 
} = require('../controllers/courseController');
const { 
  enrollCourse, 
  getProgress, 
  rateCourse 
} = require('../controllers/enrollmentController');
const { protect, authorOnly } = require('../middleware/auth');

/**
 * @route GET /courses
 * @desc Get all courses with filtering
 * @access Public/Private
 */
router.get('/', getCourses);

/**
 * @route POST /courses
 * @desc Create a new course
 * @access Private
 */
router.post('/', protect, createCourse);

/**
 * @route GET /courses/:courseId
 * @desc Get single course by ID
 * @access Public
 */
router.get('/:courseId', getCourseById);

/**
 * @route PUT /courses/:courseId
 * @desc Update a course
 * @access Private (Author only)
 */
router.put('/:courseId', protect, updateCourse);

/**
 * @route POST /courses/:courseId/publish
 * @desc Publish a course
 * @access Private (Author only)
 */
router.post('/:courseId/publish', protect, publishCourse);

/**
 * @route POST /courses/:courseId/enroll
 * @desc Enroll in a course
 * @access Private
 */
router.post('/:courseId/enroll', protect, enrollCourse);

/**
 * @route GET /courses/:courseId/progress
 * @desc Get enrollment progress
 * @access Private
 */
router.get('/:courseId/progress', protect, getProgress);

/**
 * @route POST /courses/:courseId/rating
 * @desc Rate a course
 * @access Private
 */
router.post('/:courseId/rating', protect, rateCourse);

module.exports = router;

// ==== File: routes/enrollmentRoutes.js ====
const express = require('express');
const router = express.Router();
const { 
  enrollCourse, 
  getProgress, 
  rateCourse 
} = require('../controllers/enrollmentController');
const { protect } = require('../middleware/auth');

// Эти маршруты уже включены в courseRoutes.js для удобства
// Здесь они приведены для полноты, но их можно не использовать

/**
 * @route POST /courses/:courseId/enroll
 * @desc Enroll in a course
 * @access Private
 */
// router.post('/:courseId/enroll', protect, enrollCourse);

/**
 * @route GET /courses/:courseId/progress
 * @desc Get enrollment progress
 * @access Private
 */
// router.get('/:courseId/progress', protect, getProgress);

/**
 * @route POST /courses/:courseId/rating
 * @desc Rate a course
 * @access Private
 */
// router.post('/:courseId/rating', protect, rateCourse);

module.exports = router;

// ==== File: routes/userRoutes.js ====
const express = require('express');
const router = express.Router();
const { getMe, updateMe, uploadAvatar } = require('../controllers/userController');
const { protect } = require('../middleware/auth');

/**
 * @route GET /users/me
 * @desc Get current user profile
 * @access Private
 */
router.get('/me', protect, getMe);

/**
 * @route PATCH /users/me
 * @desc Update user profile
 * @access Private
 */
router.patch('/me', protect, updateMe);

/**
 * @route POST /users/me/avatar
 * @desc Upload user avatar
 * @access Private
 */
router.post('/me/avatar', protect, uploadAvatar);

module.exports = router;

// ==== File: scripts/seed.js ====
/**
 * Скрипт для заполнения базы данных тестовыми данными
 * Запуск: node scripts/seed.js
 */

require('dotenv').config();
const bcrypt = require('bcryptjs');
const db = require('../config/db');
const { v4: uuidv4 } = require('uuid');

// Тестовые данные
const users = [
  {
    email: 'ivan@example.com',
    password: 'password',
    fullName: 'Иван Иванов',
    role: 'author'
  },
  {
    email: 'polina@example.com',
    password: 'password',
    fullName: 'Полина Смирнова',
    role: 'author'
  },
  {
    email: 'user@example.com',
    password: 'password',
    fullName: 'Тестовый Пользователь',
    role: 'user'
  }
];

const courses = [
  {
    title: 'Подготовка к Python Middle собеседованию',
    description: 'Полноценный курс для подготовки к Python Middle собеседованиям.',
    difficulty: 'Middle',
    language: 'Python',
    coverUrl: '/images/courses/python.png',
    tags: ['Python', 'Backend', 'Algorithms'],
    authorIndex: 0,
    lessons: [
      { title: 'Основы Python', type: 'Theory', hasQuiz: true },
      { title: 'Структуры данных', type: 'Theory', hasQuiz: true },
      { title: 'Алгоритмы', type: 'Coding', hasQuiz: true }
    ]
  },
  {
    title: 'Алгоритмы и структуры данных для собеседований',
    description: 'Разбор алгоритмов и структур данных, которые часто спрашивают на собеседованиях.',
    difficulty: 'Middle',
    language: 'JavaScript',
    coverUrl: '/images/courses/algos.png',
    tags: ['Algorithms', 'Data Structures', 'Leetcode'],
    authorIndex: 1,
    lessons: [
      { title: 'Сложность алгоритмов', type: 'Theory', hasQuiz: true },
      { title: 'Сортировки', type: 'Coding', hasQuiz: true },
      { title: 'Деревья и графы', type: 'Theory', hasQuiz: true }
    ]
  },
  {
    title: 'Интервью аналитика: SQL, Excel, кейсы',
    description: 'Всё, что нужно для успешного прохождения собеседования на позицию аналитика.',
    difficulty: 'Beginner',
    language: 'SQL',
    coverUrl: '/images/courses/anal.png',
    tags: ['SQL', 'Analytics', 'Excel'],
    authorIndex: 0,
    lessons: [
      { title: 'Основы SQL', type: 'Theory', hasQuiz: true },
      { title: 'Сложные запросы', type: 'Coding', hasQuiz: true },
      { title: 'Аналитические кейсы', type: 'Theory', hasQuiz: false }
    ]
  },
  {
    title: 'Расскажи о себе: soft skills на собеседовании',
    description: 'Как успешно презентовать себя и свои навыки на собеседовании.',
    difficulty: 'Beginner',
    language: 'Русский',
    coverUrl: '/images/courses/softs.png',
    tags: ['Soft skills', 'HR', 'Interview'],
    authorIndex: 1,
    lessons: [
      { title: 'Самопрезентация', type: 'Theory', hasQuiz: true },
      { title: 'Сложные вопросы', type: 'Theory', hasQuiz: true },
      { title: 'Обратная связь', type: 'Theory', hasQuiz: false }
    ]
  },
  {
    title: 'System Design для Senior',
    description: 'Подготовка к вопросам по системному дизайну для позиции Senior Developer.',
    difficulty: 'Senior',
    language: 'English',
    coverUrl: '/images/courses/sysdis.png',
    tags: ['System Design', 'Architecture', 'Senior'],
    authorIndex: 0,
    lessons: [
      { title: 'Основы системного дизайна', type: 'Theory', hasQuiz: true },
      { title: 'Масштабирование', type: 'Theory', hasQuiz: true },
      { title: 'Практические кейсы', type: 'Coding', hasQuiz: true }
    ]
  },
  {
    title: 'JavaScript для Junior Frontend',
    description: 'Всё, что нужно знать Junior Frontend разработчику о JavaScript.',
    difficulty: 'Beginner',
    language: 'JavaScript',
    coverUrl: '/images/courses/js.png',
    tags: ['JavaScript', 'Frontend', 'Web'],
    authorIndex: 1,
    lessons: [
      { title: 'Основы JavaScript', type: 'Theory', hasQuiz: true },
      { title: 'DOM манипуляции', type: 'Theory', hasQuiz: true },
      { title: 'Асинхронный JavaScript', type: 'Coding', hasQuiz: true }
    ]
  }
];

// Функция для заполнения базы данных
async function seedDatabase() {
  const client = await db.pool.connect();
  
  try {
    await client.query('BEGIN');
    
    console.log('Очистка таблиц...');
    
    // Используем TRUNCATE с CASCADE вместо DELETE для более надежной очистки
    try {
      // Отключаем проверку внешних ключей на время очистки (опционально)
      // await client.query('SET session_replication_role = replica;');
      
      // Удаляем данные из таблиц, очищая их все за один запрос с учетом зависимостей
      await client.query(`
        TRUNCATE TABLE 
          ratings, 
          enrollments, 
          lesson_progress, 
          question_options, 
          questions, 
          lesson_content, 
          lessons, 
          course_tags, 
          course_stats, 
          courses, 
          user_stats, 
          users
        CASCADE;
      `);
      
      // Восстанавливаем проверку внешних ключей (если отключали)
      // await client.query('SET session_replication_role = DEFAULT;');
    } catch (error) {
      console.error('Ошибка при очистке таблиц:', error);
      throw error;
    }
    
    console.log('Создание пользователей...');
    
    // Создаем пользователей
    const createdUserIds = [];
    
    for (const user of users) {
      const hashedPassword = await bcrypt.hash(user.password, 10);
      
      const result = await client.query(
        `INSERT INTO users (email, password, full_name, role) 
         VALUES ($1, $2, $3, $4) 
         RETURNING id`,
        [user.email, hashedPassword, user.fullName, user.role]
      );
      
      const userId = result.rows[0].id;
      createdUserIds.push(userId);
      
      await client.query(
        `INSERT INTO user_stats (user_id, active_courses, completed_courses, avg_score) 
         VALUES ($1, $2, $3, $4)`,
        [userId, 0, 0, 0]
      );
    }
    
    console.log('Создание курсов...');
    
    // Создаем курсы
    for (const course of courses) {
      const authorId = createdUserIds[course.authorIndex];
      
      const result = await client.query(
        `INSERT INTO courses 
           (author_id, title, description, difficulty, language, cover_url, estimated_duration, version, is_published) 
         VALUES 
           ($1, $2, $3, $4, $5, $6, $7, $8, $9) 
         RETURNING id`,
        [authorId, course.title, course.description, course.difficulty, course.language, 
         course.coverUrl, course.lessons.length * 2, 1, true]
      );
      
      const courseId = result.rows[0].id;
      
      // Добавляем статистику курса
      await client.query(
        `INSERT INTO course_stats 
           (course_id, enrollments, avg_completion, avg_score) 
         VALUES 
           ($1, $2, $3, $4)`,
        [courseId, Math.floor(Math.random() * 300), Math.floor(Math.random() * 40) + 60, (Math.random() * 1.5) + 3.5]
      );
      
      // Добавляем теги
      for (const tag of course.tags) {
        await client.query(
          `INSERT INTO course_tags (course_id, tag) VALUES ($1, $2)`,
          [courseId, tag]
        );
      }
      
      // Добавляем уроки
      for (let i = 0; i < course.lessons.length; i++) {
        const lesson = course.lessons[i];
        
        const lessonResult = await client.query(
          `INSERT INTO lessons 
             (course_id, title, type, sort_order) 
           VALUES 
             ($1, $2, $3, $4) 
           RETURNING id`,
          [courseId, lesson.title, lesson.type, i]
        );
        
        const lessonId = lessonResult.rows[0].id;
        
        // Добавляем содержимое урока
        await client.query(
          `INSERT INTO lesson_content 
             (lesson_id, content, video_url) 
           VALUES 
             ($1, $2, $3)`,
          [lessonId, `# ${lesson.title}\n\nЭто содержимое урока ${lesson.title} курса ${course.title}.`, null]
        );
        
        // Добавляем вопросы для квиза
        if (lesson.hasQuiz) {
          for (let j = 0; j < 3; j++) {
            const questionResult = await client.query(
              `INSERT INTO questions 
                 (lesson_id, text, type, sort_order) 
               VALUES 
                 ($1, $2, $3, $4) 
               RETURNING id`,
              [lessonId, `Вопрос ${j+1} для урока ${lesson.title}`, j === 0 ? 'choice' : (j === 1 ? 'shortText' : 'longText'), j]
            );
            
            const questionId = questionResult.rows[0].id;
            
            // Добавляем варианты ответов для вопросов с выбором
            if (j === 0) {
              for (let k = 0; k < 4; k++) {
                await client.query(
                  `INSERT INTO question_options 
                     (question_id, label, is_correct, sort_order) 
                   VALUES 
                     ($1, $2, $3, $4)`,
                  [questionId, `Вариант ${k+1}`, k === 0, k]
                );
              }
            }
          }
        }
      }
      
      console.log(`Создан курс: ${course.title}`);
    }
    
    console.log('Создание записей на курсы...');
    
    // Записываем обычного пользователя на несколько курсов
    const userId = createdUserIds[2]; // ID обычного пользователя
    
    // Получаем курсы
    const coursesResult = await client.query('SELECT id FROM courses LIMIT 3');
    const courseIds = coursesResult.rows.map(row => row.id);
    
    // Записываем на курсы
    for (let i = 0; i < courseIds.length; i++) {
      const courseId = courseIds[i];
      
      await client.query(
        `INSERT INTO enrollments 
           (user_id, course_id, status, progress, started_at) 
         VALUES 
           ($1, $2, $3, $4, CURRENT_TIMESTAMP)`,
        [userId, courseId, i === 0 ? 'completed' : 'inProgress', i === 0 ? 100 : Math.floor(Math.random() * 70)]
      );
      
      // Обновляем статистику
      await client.query(
        `UPDATE user_stats 
         SET active_courses = active_courses + CASE WHEN $1 = 'inProgress' THEN 1 ELSE 0 END,
             completed_courses = completed_courses + CASE WHEN $1 = 'completed' THEN 1 ELSE 0 END 
         WHERE user_id = $2`,
        [i === 0 ? 'completed' : 'inProgress', userId]
      );
      
      await client.query(
        `UPDATE course_stats 
         SET enrollments = enrollments + 1 
         WHERE course_id = $1`,
        [courseId]
      );
      
      // Оцениваем законченный курс
      if (i === 0) {
        await client.query(
          `INSERT INTO ratings 
             (user_id, course_id, value, created_at) 
           VALUES 
             ($1, $2, $3, CURRENT_TIMESTAMP)`,
          [userId, courseId, 5]
        );
        
        // Обновляем среднюю оценку курса
        await client.query(
          `UPDATE course_stats 
           SET avg_score = 
             (SELECT AVG(value)::numeric(5,2) FROM ratings WHERE course_id = $1) 
           WHERE course_id = $1`,
          [courseId]
        );
      }
    }
    
    await client.query('COMMIT');
    
    console.log('База данных успешно заполнена тестовыми данными!');
    console.log('\nДанные для входа:');
    for (const user of users) {
      console.log(`- ${user.email}: ${user.password} (роль: ${user.role})`);
    }
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Ошибка при заполнении базы данных:', error);
  } finally {
    client.release();
    // Закрываем пул соединений
    db.pool.end();
  }
}

// Запускаем заполнение
seedDatabase();

// ==== File: server.js ====
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const path = require('path');
const fileUpload = require('express-fileupload'); // Добавляем модуль для загрузки файлов
const config = require('./config/config');
const errorHandler = require('./middleware/errorHandler');

// Import routes
const authRoutes = require('./routes/authRoutes');
const userRoutes = require('./routes/userRoutes');
const courseRoutes = require('./routes/courseRoutes');

// Create Express app
const app = express();

// Middleware
app.use(cors());

// Настройка helmet с учетом необходимости загрузки изображений
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        ...helmet.contentSecurityPolicy.getDefaultDirectives(),
        'img-src': ["'self'", 'data:', 'blob:'],
      },
    },
  })
);

app.use(morgan('dev'));
app.use(express.json());

// Middleware для загрузки файлов
app.use(fileUpload({
  createParentPath: true,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB макс. размер файла
  abortOnLimit: true,
  responseOnLimit: 'Файл слишком большой (макс. 5MB)'
}));

// Статические файлы
app.use('/uploads', express.static(path.join(__dirname, 'public/uploads')));

// Routes
app.use('/v1/auth', authRoutes);
app.use('/v1/users', userRoutes);
app.use('/v1/courses', courseRoutes);

// Error handling middleware
app.use(errorHandler);

// Start server
const PORT = config.port || 5000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

module.exports = app;

// ==== File: utils/jwt.js ====
const jwt = require('jsonwebtoken');
const config = require('../config/config');

/**
 * Generate a JWT token for a user
 * @param {Object} user - User object
 * @returns {String} JWT token
 */
const generateToken = (user) => {
  return jwt.sign(
    { 
      id: user.id, 
      email: user.email,
      role: user.role 
    },
    config.jwtSecret,
    { expiresIn: config.jwtExpiresIn }
  );
};

/**
 * Verify a JWT token
 * @param {String} token - JWT token
 * @returns {Object} Decoded token or null if invalid
 */
const verifyToken = (token) => {
  try {
    return jwt.verify(token, config.jwtSecret);
  } catch (error) {
    return null;
  }
};

module.exports = {
  generateToken,
  verifyToken
};

